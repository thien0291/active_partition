c
prunable_partitions.count
past_partitions.count
prunable_partitions.count
past_partitions.count
past_partitions
partition_tables.count
partition_tablespast_partitions
prunable_partitions.count
prunable_partitions
c
[1,2,3,4,5,6][..-(retain_number + 1)]
[1,2,3,4,5][..-(retain_number + 1)]
[1,2,3,4][..-(retain_number + 1)]
[1,2,3,4]..-(retain_number + 1)
[1,2,3,4]-(retain_number + 1)
-(retain_number + 1)
retain_number = 4
[1,2,3].first(-1)
[1,2,3][..-1]
[1,2,3][..-2]
[1,2,3][..-3]
[1,2,3][..-4]
[1,2,3][..-2]
[1,2,3] - [2]
[1,2] - [2]
[1,2] - [1]
[1,2] - []
past_partitions.sort.last(2)
past_partitions.sort.last
past_partitions.sort
past_partitions.count
past_partitions
past_partitions = partition_tables.select { |name| name < current_partition_name }
current_partition_name = build_partition_name(Time.current, Time.current + 1.hour)
build_partition_name(Time.current, Time.current + 1.hour)
sorted_partition_tables.last
sorted_partition_tables.first
sorted_partition_tables = partition_tables.sort
sorted_partition_tables
partition_tables = partition_tables.sort
partition_tables.count
partition_tables = @partition_adapter.get_all_supported_partition_tables
c
OutgoingEvent.partition_manager.active_ranges
c
OutgoingEvent.partition_manager.active_ranges
OutgoingEvent.partition_manager.active_ranges[0]
partitioned_value
OutgoingEvent.partition_manager.active_ranges[0].cover? partitioned_value
OutgoingEvent.partition_manager.active_ranges[0]
OutgoingEvent.partition_manager.active_ranges
a.rangify
a = OutgoingEvent.partition_manager.active_ranges
OutgoingEvent.partition_manager.active_ranges
OutgoingEvent.partition_manager.active_ranges.rangify
OutgoingEvent.partition_manager.active_ranges
OutgoingEvent.partition_manager.active_ranges.max
OutgoingEvent.partition_manager.active_ranges
OutgoingEvent.active_ranges
OutgoingEvent.active_partitions_cover?(partitioned_value)
c
partitioned_value
from_time..to_time
from_time = latest_coverage + (diff.floor * default_premake_period)
          to_time = from_time + default_premake_period
diff = (partitioned_value - latest_coverage) / default_premake_period
latest_coverage = latest_partition_coverage_time()
partitioned_value = partitioned_value.utc
partitioned_value
from_time..to_time
to_time = from_time + default_premake_period
from_time = latest_coverage + (diff.floor * default_premake_period)
diff = (partitioned_value - latest_coverage) / default_premake_period
-3.9.floor
(partitioned_value - latest_coverage)/default_premake_period
default_premake_period = 1.day
self.default_premake_period
default_premake_period 
default_premake_perioddefault_premake_period
default_premake_period
(partitioned_value - latest_coverage)/default_premake_period
(partitioned_value - latest_coverage)
(partitioned_value - latest_coverage).floor
partitioned_value - latest_coverage
partitioned_value
latest_coverage = latest_partition_coverage_time()
c
@connection.execute sql
c
@connection.execute sql.delete("SQL")
sql
@connection.execute sql
@connection
puts sql
sql
c
e.message
c
unix_to
unix_from
Time.at(1719997200)
get_all_supported_partition_tables
sql_to
sql_from
partition_name
sql = <<~SQL
      CREATE TABLE IF NOT EXISTS #{partition_name}
        PARTITION OF #{@table_name}
        FOR VALUES FROM ('#{sql_from}') TO ('#{sql_to}');
      SQL
@connection.execute <<~SQL
      CREATE TABLE IF NOT EXISTS #{partition_name}
        PARTITION OF #{@table_name}
        FOR VALUES FROM ('#{sql_from}') TO ('#{sql_to}');
      SQL
partition_name
c
build_partition_name(from, to)
c
build_partition_name(from, to)
c
build_partition_name(from, to)
c
build_partition_name(from, to)
c
get_all_supported_partition_tables.each {|t| drop_partition(t)}
get_all_supported_partition_tables
partition_name
c
partition_name = build_partition_name(from, to)
c
partition_name = build_partition_name(from, to)
c
new_latest_coverage_time
current_coverage_time
current_coverage_time < new_latest_coverage_time
current_coverage_time = from || latest_partition_coverage_time
current_coverage_time
new_latest_coverage_time = (from || Time.current).utc + (period * number)
new_latest_coverage_time
c
C
c
connection
to
from
table_name
partition_name
partition_name, table_name, from, to
partition_adapter.exec_create_partition_by_time_range
partition_adapter
partition_adapater
partition_name
